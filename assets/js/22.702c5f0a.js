(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{420:function(e,v,_){"use strict";_.r(v);var t=_(56),a=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"vue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[e._v("#")]),e._v(" Vue")]),e._v(" "),_("h2",{attrs:{id:"_1-谈谈你对-mvvm-对理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-谈谈你对-mvvm-对理解"}},[e._v("#")]),e._v(" 1. 谈谈你对 MVVM 对理解 ？")]),e._v(" "),_("p",[e._v("目标：职责划分，分层（将 Model 层，view 层进行分类）借鉴后端思想。对于前端而言就是如何将数据同步到页面。\nmvc 模式： 但在前端，数据变化无法同步到视图中。需要将逻辑聚拢在 controller 层。")]),e._v(" "),_("p",[e._v("mvvm 模式：映射关系简化，（隐藏了 controller） ，开发不需要关注数据与 dom 的关联关系，转化关系。只用关注数据的变化。viewModel：类似实现 v-model ，Object.defineProperty()。")]),e._v(" "),_("p",[e._v("MVVM 模式：它是一种分层模式，目的是为了职责明确划分层级，借鉴了后端项目的思想，类似于 mvc 。\nMVVM 的具体内容： m model， v view ， vm view Model 视图模型对象。")]),e._v(" "),_("h2",{attrs:{id:"_2-请说一下-vue2-响应式数据的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-请说一下-vue2-响应式数据的理解"}},[e._v("#")]),e._v(" 2. 请说一下 Vue2 响应式数据的理解 ？")]),e._v(" "),_("p",[e._v("响应式数据：数据变了，页面(视图)更新成最新的数据。\n不管：页面数据变了，model 的数据变成最新的。")]),e._v(" "),_("p",[e._v("Vue 底层实现是通过对 数组和对象类型的值发生变化时，进行了劫持。"),_("br"),e._v("\n对象内部通过 "),_("code",[e._v("defineReactive")]),e._v(" 方法，使用 "),_("code",[e._v("Object.defineProperty(obj,prorp,{})")]),e._v(" 将属性进行劫持（只会劫持已经存在的属性）。\n数组 是通过重写数组方法来实现。 "),_("code",[e._v("push pop shift unshift splice sort reverce")]),e._v(" 。\n多层对象是通过递归来实现劫持。")]),e._v(" "),_("h2",{attrs:{id:"_3-vue-中如何检测数组变化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue-中如何检测数组变化"}},[e._v("#")]),e._v(" 3. Vue 中如何检测数组变化 ？")]),e._v(" "),_("p",[e._v("数组考虑性能原因没有使用 "),_("code",[e._v("Object.defineProperty")]),e._v(" 对数组的每一项惊喜拦截，是通过重写数组\n的 7 个方法。"),_("br"),e._v("\n数组中如果是对象数据类型也会进行递归劫持"),_("br"),e._v("\n数组的索引和长度变化是无法监控到的。")]),e._v(" "),_("h2",{attrs:{id:"_4-vue-中如何进行依赖收集"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue-中如何进行依赖收集"}},[e._v("#")]),e._v(" 4. Vue 中如何进行依赖收集 ？")]),e._v(" "),_("p",[e._v("每个属性都拥有自己的 "),_("code",[e._v("dep")]),e._v(" 属性， 它用于存放所依赖的 watcher （渲染 watcher， computed watcher ，watch 用户 watcher） ，当属性变化后 set 就会通知自己对应的 watcher 去更新。")]),e._v(" "),_("p",[e._v("默认在初始化时会调用 render 函数，此时会触发属性依赖收集 "),_("code",[e._v("dep.depend")]),e._v("。\n当属性发生修改时会触发 "),_("code",[e._v("watcher")]),e._v(" 更新 "),_("code",[e._v("dep.notify()")])]),e._v(" "),_("h2",{attrs:{id:"_5-如何理解-vue-中模版编译原理-核心问题-如何将-template-转换成-render-函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-如何理解-vue-中模版编译原理-核心问题-如何将-template-转换成-render-函数"}},[e._v("#")]),e._v(" 5. 如何理解 Vue 中模版编译原理 ？ 核心问题：如何将 template 转换成 render 函数？")]),e._v(" "),_("p",[e._v("主要就是做了三步。")]),e._v(" "),_("ol",[_("li",[e._v("将 template 模版转化成 ast 语法树。 "),_("code",[e._v("parseHTML")]),e._v(" . 使用了正则匹配方式，一个对象结构，记录 html 树结构")]),e._v(" "),_("li",[_("code",[e._v("optimize")]),e._v(" 对静态语法 做 静态标记 markup 。 用于为 "),_("code",[e._v("diff")]),e._v(" 阶段做优化，如果是静态节点就跳过 diff 操作。")]),e._v(" "),_("li",[e._v("重新生成代码 "),_("code",[e._v("code = generate(ast,options)")]),e._v(" 。 后面通过 new Function 变成 render 函数，将这个代码执行创建出 vnode。")])]),e._v(" "),_("h2",{attrs:{id:"_6-vue-生命周期钩子是如何实现的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue-生命周期钩子是如何实现的"}},[e._v("#")]),e._v(" 6. Vue 生命周期钩子是如何实现的 ？")]),e._v(" "),_("p",[e._v("它们是回调函数，当创建组件实例的过程，进行调用对应的钩子方法。"),_("code",[e._v("callHook(vm,'beforeCreate')")]),_("br"),e._v("\n内部会对钩子函数进行处理，将钩子函数维护成数组的形势。")]),e._v(" "),_("h2",{attrs:{id:"_7-vue-生命周期方法有哪些-一般在哪一步发送请求及其原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue-生命周期方法有哪些-一般在哪一步发送请求及其原因"}},[e._v("#")]),e._v(" 7. Vue 生命周期方法有哪些？ 一般在哪一步发送请求及其原因？")]),e._v(" "),_("p",[_("code",[e._v("beforeCreate")]),e._v(" 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。")]),e._v(" "),_("p",[_("code",[e._v("created")]),e._v(" 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el")]),e._v(" "),_("p",[_("code",[e._v("beforeMount")]),e._v(" 在挂载开始之前被调用：相关的 render 函数首次被调用。")]),e._v(" "),_("p",[_("code",[e._v("mounted")]),e._v(" el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。")]),e._v(" "),_("p",[_("code",[e._v("beforeUpdate")]),e._v(" 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。")]),e._v(" "),_("p",[_("code",[e._v("updated")]),e._v(" 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。")]),e._v(" "),_("p",[_("code",[e._v("beforeDestroy")]),e._v(" 实例销毁之前调用。在这一步，实例仍然完全可用。")]),e._v(" "),_("p",[_("code",[e._v("destroyed")]),e._v(" Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。")]),e._v(" "),_("p",[_("code",[e._v("keep-alive")]),e._v(" (activated 和 deactivated)")]),e._v(" "),_("p",[e._v("在哪发送请求都可以，主要看具体你要做什么事 !!!"),_("br"),e._v("\n如果是 ssr 的 vue 项目 ，会在 "),_("code",[e._v("created")]),e._v(" 钩子上。")]),e._v(" "),_("h2",{attrs:{id:"_8-vue-mixin-使用场景和原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue-mixin-使用场景和原理"}},[e._v("#")]),e._v(" 8. Vue.mixin 使用场景和原理")]),e._v(" "),_("p",[e._v("Vue.mixin 是全局混人，使用后每个创建的组件实例都会被影响。一般用于作为 "),_("strong",[e._v("插件")]),e._v(" 发布。")]),e._v(" "),_("p",[e._v("原理：当组件初始化时会被调用 "),_("code",[e._v("mergeOptions")]),e._v(" 方法进行合并，采用策略模式针对不同的数据进行不同的合并。如果混人的数据和本身组件中的数据冲突，就采用“就近原则” 以组件的数据为准。")]),e._v(" "),_("p",[e._v("建议:建议少用，会用数据来源不清晰的问题，命名冲突问题，依赖问题。")]),e._v(" "),_("h2",{attrs:{id:"_9-vue-组件-data-为什么必须是个函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-vue-组件-data-为什么必须是个函数"}},[e._v("#")]),e._v(" 9. Vue 组件 data 为什么必须是个函数 ？")]),e._v(" "),_("p",[e._v("每次使用组件时都会对组件进行实例化操作，并调用 data 函数返回一个对象作为组件的数据源。这样可以保证多个组件间数据互不影响。")]),e._v(" "),_("h2",{attrs:{id:"_10-vm-nexttick-在哪里使用-原理是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-vm-nexttick-在哪里使用-原理是什么"}},[e._v("#")]),e._v(" 10. vm.$nextTick 在哪里使用？ 原理是什么？")]),e._v(" "),_("p",[_("code",[e._v("vm.$nextTick")]),e._v(" 中的回调是在下次 DOM 更新结束后执行的回调函数，用于获取更新后的 DOM。")]),e._v(" "),_("p",[e._v("原理：Vue 中视图数据更新是异步的，使用 "),_("code",[e._v("vm.$nextTick")]),e._v(" 方法可以保证用户定义的逻辑在视图更新之后执行。")]),e._v(" "),_("h2",{attrs:{id:"_11-computed-和-watch-区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-computed-和-watch-区别"}},[e._v("#")]),e._v(" 11. computed 和 watch 区别 ？")]),e._v(" "),_("p",[e._v("底层实现：\ncomputed 和 watch 都是基于 Watcher 来实现的。\ncomputed 属性具备缓存，依赖的值不发生变化，对计算属性取值不会重新执行它的方法。\nwatch 是监视值的变化，当值发生变化时调用对应的回调函数。用法 可以对对象属性深度监视，立即执行。")]),e._v(" "),_("h2",{attrs:{id:"_12-vue-set-obj-prop-index-value-方法是如何实现的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-vue-set-obj-prop-index-value-方法是如何实现的"}},[e._v("#")]),e._v(" 12. Vue.set(obj,prop/index,value) 方法是如何实现的？")]),e._v(" "),_("p",[e._v("这个方法是给对象，数组增加响应式数据。\n当给对象新增不存在的属性，会先将属性定义成响应式的，调用 "),_("code",[e._v("defineReactive")]),e._v("，然后触发对象依赖的 watcher 去更新。\n当修改数组索引时，应该是调用数组本身的 splice 方法去更新数组。因为数组初始化时，已经 splice 被劫持修改成响应式的了。")]),e._v(" "),_("h2",{attrs:{id:"_13-vue-为什么需要虚拟-dom"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-vue-为什么需要虚拟-dom"}},[e._v("#")]),e._v(" 13. vue 为什么需要虚拟 DOM ？")]),e._v(" "),_("ol",[_("li",[e._v("virtual dom 是用 js 对象来描述真实的 DOM ，是对真实 DOM 的抽象。")]),e._v(" "),_("li",[e._v("由于直接操作 DOM 性能低，但是 JS 层的操作效率高，可以将 DOM 操作转化成对象的操作，最终通过 diff 算法对比差异进行更新 DOM（减少了对真实 DOM 的操作）")]),e._v(" "),_("li",[e._v("虚拟 DOM 不依赖真实平台环境，能实现跨平台。")])]),e._v(" "),_("h2",{attrs:{id:"_14-vue-中的-diff-算法原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14-vue-中的-diff-算法原理"}},[e._v("#")]),e._v(" 14. Vue 中的 diff 算法原理")]),e._v(" "),_("p",[e._v("Vue 的 diff 算法是平级比较，不考虑跨级比较多情况。内部采用深度递归多方式 + 双指针的方式进行比较。"),_("br"),e._v("\n采用复用的原理")]),e._v(" "),_("ol",[_("li",[e._v("先比较是否相同节点 tag ，key")]),e._v(" "),_("li",[e._v("相同节点比较属性，并复用老节点")]),e._v(" "),_("li",[e._v("比较儿子节点，考虑老节点和新节点儿子的情况")]),e._v(" "),_("li",[e._v("优化比较：头头，尾尾，头尾，尾头")]),e._v(" "),_("li",[e._v("比对查找进行复用")])]),e._v(" "),_("h2",{attrs:{id:"_15-既然-vue-通过数据劫持可以精准探测数据变化-为什么还需要虚拟-dom-进行-diff-检测差异"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_15-既然-vue-通过数据劫持可以精准探测数据变化-为什么还需要虚拟-dom-进行-diff-检测差异"}},[e._v("#")]),e._v(" 15. 既然 Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 检测差异")]),e._v(" "),_("p",[e._v("响应式数据变化，Vue 确实可以在数据发生变化时，响应式系统可以立即得知。但是如果给每个属性都添加 watcher 用于更新的话，会产生大量的 watcher 从而降低性能。")]),e._v(" "),_("p",[e._v("而且粒度过细也会导致更新不精准的问题，所以 vue 采用了组件级的 watcher 配合 diff 来检测差异。")])])}),[],!1,null,null,null);v.default=a.exports}}]);